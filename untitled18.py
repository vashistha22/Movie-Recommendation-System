# -*- coding: utf-8 -*-
"""Untitled18.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oKZ9SYJgRz3Ji58vo8Gu3tMtAeUl02hW
"""

import streamlit as st
import pandas as pd
import numpy as np
import requests, os, zipfile
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.decomposition import NMF

# ------------------------------
# Download MovieLens dataset
# ------------------------------
url = "http://files.grouplens.org/datasets/movielens/ml-latest-small.zip"
if not os.path.exists("ml-latest-small"):
    r = requests.get(url)
    with open("ml.zip", "wb") as f:
        f.write(r.content)
    with zipfile.ZipFile("ml.zip", "r") as zip_ref:
        zip_ref.extractall(".")

movies = pd.read_csv("ml-latest-small/movies.csv")
ratings = pd.read_csv("ml-latest-small/ratings.csv")

# ---- Content-based filtering ----
tfidf = TfidfVectorizer(stop_words="english")
tfidf_matrix = tfidf.fit_transform(movies["genres"])
cosine_sim = cosine_similarity(tfidf_matrix, tfidf_matrix)
indices = pd.Series(movies.index, index=movies["title"]).drop_duplicates()

def recommend_content(title, n=5):
    if title not in indices:
        return []
    idx = indices[title]
    sim_scores = sorted(list(enumerate(cosine_sim[idx])), key=lambda x: x[1], reverse=True)[1:n+1]
    movie_indices = [i[0] for i in sim_scores]
    return movies["title"].iloc[movie_indices].tolist()

# ---- Collaborative filtering (NMF) ----
user_movie_matrix = ratings.pivot(index="userId", columns="movieId", values="rating").fillna(0)

nmf = NMF(n_components=15, init="nndsvda", random_state=42, max_iter=200)
W = nmf.fit_transform(user_movie_matrix)
H = nmf.components_
pred_ratings = np.dot(W, H)
pred_df = pd.DataFrame(pred_ratings, index=user_movie_matrix.index, columns=user_movie_matrix.columns)

def recommend_collaborative(user_id, n=5):
    if user_id not in pred_df.index:
        return []
    scores = pred_df.loc[user_id]
    top_movies = scores.sort_values(ascending=False).head(n).index
    return movies[movies["movieId"].isin(top_movies)]["title"].tolist()

# ------------------------------
# Streamlit UI
# ------------------------------
st.title("ðŸŽ¬ Movie Recommendation System")

st.sidebar.header("User Settings")
user_id = st.sidebar.number_input("Enter User ID", min_value=1, max_value=int(ratings["userId"].max()), value=1)
movie_choice = st.sidebar.selectbox("Choose a Movie", movies["title"].values)

st.write(f"### Recommendations for **User {user_id}** based on **{movie_choice}**")

# âœ… Only 2 tabs now
tab1, tab2 = st.tabs(["Content-Based", "Collaborative"])

with tab1:
    st.subheader("Content-Based Recommendations")
    recs = recommend_content(movie_choice)
    st.write(recs if recs else "No recommendations found.")

with tab2:
    st.subheader("Collaborative Filtering Recommendations")
    recs = recommend_collaborative(user_id)
    st.write(recs if recs else "No recommendations found.")
